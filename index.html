<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f4cce0381e3d6668bc309f3e2735e37c7316711eed87a9c2ca4b69228f58f9653da921957b5cc767b2d4bca19c824eac7dd96342165760fc6273d0e03a172b88c21e6dc847ec411d91ac15be81909d5ef921c1d924d00034211fb0a4f0df91a58097b5ec233b5969d7821ab1ec9736d0b6b6a33ed29666b679d3f9dcff2488d1a75caf83d043f6a0020c078c0aedd5afe4aec40b2f552ff52df3d39e3468737dee42e59f963649c0eaf48bfc972355f4e7fb79eda29de7d6dd708bf47ae2b6e015d04659e2bed24bd9f5613c4aabe6c7a8f6687471b2401fbecd0b1551173bc764365f00f45f44cfb0d0b3b27414cd4516d5a1c4e5886568755894033442f4d768bada27f664cbe527b81644893bd8c9bb63f0bf60d0c8dd9cf323f50f9b4fe98f91f37aa10471b063d8a727bb87e73c19e6ceaf850864caa467829ade798cbb5035d697f6a195ef3783ef874565e4a9367c6f2b981763dc6a9fce9369372f22a48210fa749a76070f57365d1db0db0392c8e0d8ed549bdd6b927385867b5b170e9426cc30f74284886b78bba7004b493ec850976676ec087d7bd86652140d5d3788046a708144aaafb08abca5fec10fbc5e9f81d0f6d50ced82751aa16c6e2a6de3cd4a6cb7561ea61b19ac9fbd03073ed2ddf4f6978eae1f1f319fa1188e12cca114b47eb13073e1c4f3be3c609796a5725718547bdf92d38e2c4625dd55c896e248c048845431ff12eb8ffbc3c130fe18a201860002aff39247e32c614788e014074beed6143c40a43ace388f71e9e123ac0c0d205f710cabd186b6c72d5f2f1503dec7a007da5b16dcc35c058717e11c9ec9bb27e63ef8ed6e9e5993176a3ae2d948c02e2ca60eca744d4267abe46bedfdfa3bc5d4b8e0b5e3828198d48cdfebe48f2ddb66da905c42c5f6d827e8d13ce9fdb924de9f87f21813032a4f8422aa39b057303fac297fa5babb997a7a9eb3bd87be8844072492dade954200aafd52d55e1e285a542f410ccda9d9e98c552741e5c8de609c7b4e7ac284ed06864179df2516937c669940512363f57770f1a137b0f6e8b4bd07f282bfa4dc1f4e736e9e8c6130e83cffb39dbb60002eb9655e57b22f5da167c770d476bfbfd6e9020a258c1f1e31545262b04c04298295fde1254e8c37d957380410506cb7dcb8ac0919ccf941c44624b8caff75911300def6a4c1451b40119ebb99e6e969809c9a7d82271316648b6f060043ff72be263dd55c001ab257d098f433bc043eb3d54a0426ebb7133fa5bc6eb5b705cbd5e91132aeaab7703be69e9a8f1c2ef6131439767e03e14d9ef65116fc405e59795cbc9a247fed2eb44a8a35bda6c848a24c7c866118bb788526b4dddc5551de9ff505bc7fd4d70b6b258d0702853a2033c865dadadccdddb0b11411cba9e147a3f99c2cd403b6d7f2fdc885f308dd4cc86352501d564c69103064f959cbfa100c7a17a5caac6ee393851ca03ed4c5fad0f223cef226dc8dc32f18e877471266d7f782d0fe19f9391029979515a74a57ade757091fb21c1fb267bbf3aea8683fbf31385b332bad63f1a5c86b73552423b05c26e26b3913378cfa8ad95d827f28cd7b407440b10422aac493ee696345ac1c5241f4ced99853480143ddc15f07622005a8d5b9a8d9c8be934d305b28aab2ef172da850b41e916617ea7fdd5706cd84b0624840d2ef8571b783b6365c2852e33531402d4725ed3eef661491a08ec2094ba32faba13ee599164e3776c793897c858c3426217a43bc2683a66655d810b123450ed3e51f8a8f8850d249ca4344d0d562bc290153378b1c60e7412050660b7cb3ebfd567d9aa89f3eada6c7ea572c9463cb905bd602d3e620e849dffb2857c1599da674f25505c2b494107164225fabeb8560d14a2d408de13d4c98c19f1386844265096d9cf4674f84179e65a405ca0f4ecbd7e86049c7b51f562a3e16c69082be5ab841fbe3c8dafe04f7ab22e81f13f1560d0e3718df3061b91dc89399d5e7296a9db207ff1daa4e86a851b04b3520b920cf2a9cdb35aef590ffa53543cc74efa0d799ec58d5c277410f2add54b0ad0612807dff23cf355d0684129a88c90a4821ac2517abc4c402a0591af2f1c25f694f7a8732bdda109fe1fe17e9f18ac87fe68f4586f670444c88a3c75d2a50099886feb2b208be041d3519d0b94f0db6c2bbc91ff6f04d8d36b96a319df7792d9757230ae86d33c9fc5dd2cd60e873a8d2a244ea923eaacb0aaa1996cd881911ef072727d99c4605e8aed16f415d068e36f9df6c2c033bc45a454db6c19d08d32ccb76dad01958a6e1e1f468ca58722aa3f17a7c29c84ba0e37c95655948e69c5421829d404ce41456f2315cc1e532588203b819aed913bd060ebea5445f7e1c8ea16ac571bb3a4853c1b805f4713207bb8a005840f86030351c10b01623a950fca979f9aaff5af278bf539e8b592d449a65bc9ad715b3674cc840c440572eb80fbf79617e9121d7414863795e778b3013e5066b63fadbe2225eb35844295a7dc093daedc37919db6580b8dfbcafc9b539ea1ef8a51dce830b708aa1d28c52bb28c5919c1a2dd5658ea2dfe55b080efaa96b4f0201cef68207b0e0a89c766a9424141865dce0e2fb49751b001471da79102611541660a77822149d3b55f4018587021608de47e19a38888363e67f2e83e38ab50dc509e8a060358b22f8b106c201a22509f6a5adcb4e8cbd34ef77e2f135e3f29ab426e3d49fcff7efb3147ded0de7be3b1b6d1ef1e4861d6496573c8551e3bf9803023696945bb41acae8516304ab39935397e63ceae2d92834d15556754cf195b271db5de2a1e6b671fbd253365c634c5f7f0f05a810f8e070bba3717844486ea56fa659b1b52f5b84aa6f623c44180878097aa928424acad86bec1d2d5549cba8dd6ae46fe6bfe681bf6ed702b02b4d911046876712f14694e6d9001d73956cdbbc8a24b7d9ac421c7f16154cad1613a126870d687be8f59e40dd9b1e5e836630ed54870f8ff74b371bef67a7b8dc6f69ef1a1b5c710e4425ff24c68b0cbdfd5d39752671d856cd0f2ca8cfdedf66f76777e88dd709ee543eb8e6c5f37be78aaaf76c1eb2dab36802d6bab6ffc409f89a609b385cab37122bf0c3e677c802449e2e278ae5f9cfefbcc2b94ec24c51c958cf1c28df497c5175335e0884756cb4d510f41e20bced516bbae046bab1a615b56aa7dd489a5b55da1cd35f78388efa3ebf9ac6813017d6fa556a39ef69ec261bc4a28a59ac8045a78b2dc9efe2a7852b67636b173264ce67507c53368dd14ee5e06881fa2f81cc832927280cfec70ce58562813eb338eb66b1c5c8ad9583a8cd1c08d52a30d0fab119da01bb5ae53358f5c798a1d6206d435cf3e8f6c88ea89097fd65a41192a32d860c8109036308951a7e04e133c5f04c3027e50147ac624fc93d19f04a2e7b21dedac6d44383ebf745b6a1197512f472ed363adc47e06db8aa72cbb94e43aeae152130b7eb67536d9a0131764aded1a0f4922c9430b3636f726a4884de847e3e351f24aba911733f9e702b9b9a4692bd0fb351e45418bcd4e47b07b7956608ff0bb57a6f3f3c8040c94e0fff023a38d4145d8823f24cd327a4ed4025a39835eff94011782eecf0da57b43c75f2d11353b384200b830211902ef804eec32836b50c761fea4a2608e9c2e6e9e6d26ff8ae71a61ce8c0abfeb23a29a99449078998d0f42711f69f245f9ffc9e82ff3933025f0a4ae6371c48f536a42c1909306a9c598c0658dd6513b5e445c6631b9a906a567c02f422390dcbb73f4b31c9189036bf38142ed93ea14f64b37732612a5319d68858a7afd610eb97044f59d8397fe54e7770bc789da321e9c4b3b094714ad253930065a6b4bc9f739b301f0f987dfc9f25782585aadd76c2452a067f928b195e3ea1c0a9bcb4aea58d79cfe67643d8c0da1046b64c4b95c85bea3242d93aafe2ad1b544c6e12e7b0d7aa3fce6c3a33d98fdea41ab0b27d5836bdccc31c78f0781eb4a8ec019db3cc2b3720d6849bdaab3dd89bae46a9ebf2993f3e4961ecadc9d2e734db19a367de189b1677141e188a4a3c0ed3be11122e4fc282e4b60d0a6d4229b9906a9197cb4f59e09eeef6905362018fa7f574885ab91551fc8ccfdeb9be7ac5f64157e465466f308dae693e3dd9e82b2ae57c0658319215cb4b04404ace76d367ce215e2d7a20c3b14b79cb22e33fdcca2f4c60937d7c65a6096b4ff99c08f5cf22b43f55ea82c66c4d81b38f705bdfd5c1b1b8c8251228b5f6cea1b83251806008f8426be4b4bf43a8ba562af2336cec3a95d0e972faac1b3955f1e6d77059156136b0af0f2eb950e8f0b22333c78b2a306c401ae3f892e0677253231bd246d7f09542884629922c12a1477e09eb802ec5a77187615b9f67bac49e094a4a29c52dc4ec72eb7a79b0fefb0d3ef7841f1dc09b6b56dcd980d9dd0be75cf8418c0f47073d418589267094739136ff98aed328775062188cd5a3fdda11cd379d626e0d3139b6b6bf53ca301205090de031545bcbeaab8b842179e39242c8c1ca2d1fa139b51070cd1e323f1219c232118561a9b8b64e1511d66fa0bd2037ad001a7627e5c78b77df7aeab056d3e34b8bedf213154cffabb8a8f5f3a34d714bfe75a8c38ddf4107211c6482b338c33da004145957803f53ff30c40f2dd9c9de277e3873adfb30b9150b2f916545b563044efb29e6474a41cee93139caf57bbff82e55cf9c64d3550552ece378cf97cb4a902a0a7680e9100056012aea6f7b51933c6494bfa3dd96c9dffc3dcdad09c37e78d3ee47502227742e15093595e83fab89c558d9810a3f215f4f4a316c8e5b5f115800b70a124b94837585503e576afb2480a834c487d3d426d2860c5e579c88b446e44566b70840b9f3718e5438661c22499a7da16fd557e4694770760030259834bfab2024888ed1da05bfe131661a645c3dfc966aeeb4b63f17e07f821f0e3bbbe39d9a0ec5885b7ce0380309a49b0fb9c5fbab061d8be802050a6a7339f928d02ed9cbc8a62e93b2f7193a241f28964df0e5b17d3ea61eaa1926eb6434cd897e14e5fbc2761638b1f9766251024587414c42ed29c195b23366a9c73e8bfe7cc6e1136e86eaf7512b3b337fba9318fadbc44bd8b7b1fa2189a44b7bde9c01822ddc2f372c0b4991fc1922b0cb2d87b5f9b10989226ed4846fc4900ebe37da748710c91242a8264cce451e46ad0fec322852c4359e469d6b3767afadbd5819af84fd28aab7e28ca7db87bbde21f06d90718e6c6d3c024d274b2a5a61b783efaf8a0adbbf0980e425b422e47698949c0b1eb49c003f1a5adb902f3838975cb1b31fefa9eab1f7b0946481a6e5d1f953b12972b0dd4134763feb5751bce1b3cdd8c804eaa84d49327e51c3abdc806039b57e184454beebab811f9d4a066e2cc59f4c110d79076e44d934183c463783febf3c7da690e444876dd0995bf696a65277a246d991c98b1063ac37ade45c113af8510c00c97037ad0fb87ad0913997d9ef0128e5608398d491350c31d3421d14db894d203868a458f3e078ad35cffff7c4d0d639d82cd4159c93607c716fd4e03b12ee9541321a9edc4a0f811313012a0645b8f507c2f02be006f330063eda71aee9d57ba2fc56eb1fa5b2183c40475721b8b7c8b37aea7a656d3d7890a74e941695808181e106e265b1f69f9e069a6f3a5cfc45f23e027946f1bb528c335883a0aafa3fa414ad57105bdfa5a9e806db0f36d7ae6178a7a3627bb186199dc48ce91b0f1b8e2cbb9d1d619fcaf22fb4d1faba6b9271db60f2e7f3cbe6387ea3b667d6a524a4ebdeed276b1abdd1dc37c313ef1bd2ff90c72a9041dd707b914610400e4cd4d87d345bfda55c889622dd0184fdcbcc7c42f41e3b5ed8cef9e168d9476c517d0e4f2079c525fdc1a8f7a0756187cf4a353047f323f5ad312d9fa88d60b9b7f8ec2e8238f08edc3d47b1df17f4a501c76c42eab3d0bf5e215e8687fc3ac7dc31f64f732f8ce84a4d1d66e538b8b54177a75a2a4702ecd14a210962f00f3e7b75cc64d5ded3cbf2a88eb6230996e051bd2462fe59425e6dfd023cd83764b05127d206c3a737d63d5b607e6911a1a776fa7aacb717f21fb8bb1fa43930bdd7284f721ccdb9874fccc78fa73496adbe21857b982f320b24a105c14df7b174ed3a85a22f7cf67605ccb649d176fd03ada66d795174f5621be348d9406c2efa088c49f739ec1fe7b10b233252e5a8deb8cfc8a912244861c3e0173eb3667d1d558eb5e7d3f5f9624fabc926f246847458d6da49d4b1d35caddd3dd80f16f3d686088b84406a6e1581db3ea2269f599f99dda515b77891555520c369fc6cfaf7f758b80690d6a221490200af46688cf227af92b58eda6e42c176be58fbda5e0bc7d682129ebe26ccc938de60ad21d62e9a234bff1c7ad27fe23fa7ca5b2eca9cb2f48bf1bae0fd3793f56e908d142378ebef58945eba0ba0addd70ad8be275342037d5c06f69d6c5548e141e2eb103fa8e00a3f83633093874d32b27282cd72af991f98bd7734a1f754ac341e60e2c8b861ba2ea01d841cac5b8cf893d990d4df89b0fb45b14141925f8bf45006f115fbdb83b4dac4410e0ffde617b17ac737232e002cd68f4149fe951bc897863d7031e4b4f68f775dbafc52bbac2fdea04cadd44d1d6f1d463be68c762ee78888ed91468783d8b7a1609ad6133c16a66d89c5b74ac46b1bc466435c93223e816b0786d94ac609c42829201de5cffc91703b1c4932970319ce277ce1cf1b356c07fb1091105350214188c20a57ef62b69f3309cf511277bc2f2d214ec496cec92cd0fd385b7af100b119978d53cb385455945f5af59bca17e0136a5ee6c427f01cbd914c858bfe5fae3285d3bc006ef17b3fe62f2a77a421493f53033ff366d52a78cd15a7cdfdc499922b18a4a72a4aacb13d4b1d6831147d93235b24df50e7b04ad90f8c57448d860b75045365af02dc9e95b62efc221be912002f7c4b2893eed2eebe6521adf210e6bbd51a2ed530e41c3b82a9bed4785cf811a5f2b0482d091c294687d492f7e02be3c0a2db291e78cda1ce5eb1838ee2d2121ce39a3a27f8633fb2b812d96a99bebc65e36b212b37d0037c03c1d462ca512946f24c95a82ab37aa1a96f91f0bc08c411476391c62153556d129e20766f5b65495af06bc7ac8e3a51abfbd5d46366aac9e8af82cf2d225c7e3649bba6c10843b69adc6edac8a2267a908f9acefebb169d53722a6a661d4ea620a55b49c56621c96521e9de157d665c1dcbfc7eda8f2225c3561df9012af68afabee9edc44198ebb38d2e8d31ccaed9b0629411e1de0408c8ac0e590204ebd30560324b809e6a2d0148e5d664d8c3f2bbec2c79155158a4fb51e1e4dcf5a2fbbfca82da7df5f26fadeac35ae819b97105f19dc4369a64e7ca5c9563058853cd55c9e573890832f8d7c92c689aa4aa14e0bf17d4cabf8952b04d522c12d8aeea44cff9ab822def46a7dff32cd93099de74366ecf5237a98bd6eff4d26a708d89e075438cfc6a70129a03a0b15b4ca9052ca196b57da484dc9cf268f95c3bb3b5a505385c75902173c62c8e1bcd9d025fa3b6e778a71ffa5313229cec9904fba5eb3d2a47ac396c2d0a74f9aeb9956bd8639fb3b2463f9db6d2879a4513ad878f75d03216b785f5d121e2bf8756b040655a309c727d7dcefc9acff9da615869233a914216304adf33598a012e688928cd1651becf0439666bf48b8b3857f7d170c42a3038aafd5f3ba101ae6f043360d92aad0dc17a974c7ef905edfe6f373ea53673c2045a0c47a4f38b1b7be978c685b48f4bda5e3d144edbea148887298ce13ed7467aff63aa4832c64fde96a725c10fae4ce397fe1c11553f52c980812a20983d09c196f6b69e871f5ab6e6aecb6a859c69e49d77e39d642faeff66de3beaded36b41cacbc9dd177dc0ad63bdd06f7b360e519cf6e1ab384978a7416b8ea35658dc338468de7c777d7f2b38e71f1a02a58bc10fd78bd515a92b99b10a24b7ce4e8ff17e7dc97d7ed39222891e724ed4bfff3da4b20f4ab52b71c754bba55b0b15e9ad3303bc6edb0c113a285bb2739cc7ce470f49c1b1685a7710449eb89f4be5f87034460d282ebdc31cabed14eb3c0ca7b6eee4c2a192a6039010d5c28a075a195ad9cf33a27e51cedbeb86c6172f0844765ea65a2e37635361dfc7fc7e60e083a85e02489ddb28435e9ce52c500bf475a1af2869e15da239b72f46ebb8e4d7a860aac73b9a6db7e77859935f4c88fbe5bdeccf8f6b90885ff4d12dbc601ad807cbd496beaeb28113b2c47b4a7fd55ea2829296836299ccc5a60a9a84a67b66d3a44f8a29f5a8ab00b0894eed940fbecd6cf70503f7b0f520162f5ca43feea4513815fd04fe686e2c214bf2db304840b6c3b883df11a6bb1b6e2a2db41a9230bc0617786d65daec4a419079973408af3d566f29d0057ec000db68a0d42934517306999fdc4a68230e99ecd7b48eaa82f4723ca4ee457bac54d5459e7d67decea8d36cc10f623e1ab80fa6f9fcce9edae59b94cc44316c41a16a6097815cc09308fe451fbe96afa5a52c9628cb49ae2164a443f750b9fba2d87060d3470ffd3c283d339a06733aded3d2ef537808392efccc1efe370f172a28ad196df48bee1bbecf4ca7852cb2e4f42c2821579d214b6bd3d9963b821bbaa8ce58e2d83d364f368cfa9f440f893ace8679d9d2b8643901d725f92adf8684a27da6b603ca9a84328188f57a9ca6e389777f1a17eff6c6d847409a742395ac899f1ca4687719cf21f0fc26a98d4b9e5f6d63ff691e3cf867e4a18e3947ffc287fb650dfa83f3e464caac6346d7939094c3278098ca42a93d2adae201e02f134dc967ccf13092501bd53c773f770b07eb1ec8e51b6fe5dfb86dc1117032f72c9202058c8030deb387d2033739c35723ca7c279ab6f00f304001f0666bc68947c6c2fdb49b78bbb990d7ba7c53f31618059ae24d2e4256b0214459a242376a5397da561c8c02dd22636b97c0be534137be4f9b9beec9fc7cb44ae6af5d5139c7d5802ff431478f8442b85d8f3de51d3dcbddc28fa17cd054d3e2e339057aa8faf3645357ce539e1349cdc8a2d798f5713e82c91b73223d106dea386227e88182a172b4b39070c46c546366957b7a69e1e79bcce4bef2a7d4d919f3ead6bc12cc7a74e5de8084f8d8930ad0dc35d5c698c6b4d396273c34127f3744cfa2099c30523f168de30af325e96949774f46851ca35764fafe1970d276c15d0a863a500d076b8a162518d0af7252fced6734b12a094a19da6aca2f59e672cf8971e2971977897f858eff1dbbb5b18714cc84ff60289fe12fdd4459f105637de6934d06a0e4e82e2dc3fce00baf2614272a8c73a34228c9bb7026b2e2fff1146b3c5ac67492257e86a599f7eb4979b8c1affae5d2c2047c734d75efa84bc850eceb8c48ed9752ec95811d752766482f4eb4bfc8d5c57dd5730592d40b88f22036afddffebd6c71d6ca6528a5a66c6fa4ffcf873d429d8c39c67e35c61662e84a923794a8e6664312de3370ff4fc86a1289bd039914c2fb52a685412f6c1cb3a6d67ec5acb544ac8ffeceb6ebb973a09075fbe5de2a93f1af4383f7e76b94f1f3d9fa2bac60e964e6d1d26f39980b8d51ec1c8a268fbb8b54359e6df43ae7e6a0ed3f12210b58c68e339ee61502eed84c192e63bb6d979301458094b1f874d3e3df617fe03fd934968800d10cd65b0e44873897355b5149a017239d339642fc0ae2e814ec3badd7d6a245137c5dbb077e8c76bc116c25afb1f7f0d545d30b1f5395070a24c2ecfb803f888395a0a69a9ed87c0372ac519bf18ccb3146022156fcf77bdd11489eac5173253c94739ab033480852dc234d0b2c6189f2e78705a797c8d24fb84c20b8122509e07e654fba38bd7c4c5985b54e7bb3faa3f7982ff052b24a62b95c6b50efa626378f1b0057ce5960c4ba7a2384761ae64863c6452b7d279c26f736cf6092817a2c81d623dde20896ee8cf0ab20794a7d216c0d281147481493e113a572d4e490a5b1cdbab1c2f00247201754dce656a61d4183b40889904a8bfe700dd140bb5d1dc12f6afb5f087976aecac21c7e53ec228a31b312e71c8275a5e14573faa229ed271d25d9ad47d3506980c598dd894917246300b96dad374e8e0aa25de1db542b794a150625c1279fbc71cfebf9bf273c9585b168dcb41c2a9cf41f58bd5a46e536d3b04e673df831e7ff71f5efee1436312b9a3679031691b57aa08a2086aed2c9895c35604cb38695d426769ac5a5d7f9084e55ecc92e57d9e0861c1d398d6b15da93e61a318f2b4f0a74cdba251cd767bd6b13e496b41b3d7a8a96e93a8d8b1932be3ae1d1c937c63c67d4ae6362b5dfdd73e70431b8207acd1fa93ce6ab8a2fddbcb57d9daeffd771a61935e338c070d23984610809cad11a53aba60e8a6f4f66ff29a7a6ee7db7629378788d536f2998805ccd755247321a9b2d1e3f4dfc41def531fb1d82523366c64896b123ea90d292e488e0cd3ac45a1c688ef70e97b20190e3f1ded3649881abe9e297193a7a94684898a49dc24405246abe35c0cde79a80d050a439781856e043b1f78ec9ea58d7919a9c4320f41002d1f4fc71604cb447161c4d0d202b170b195adbbadac3b3ee27cfc7a606b1dde1bf9f21c454c2077aaeb16ed4ea4d12170e75ef2c051485fa23090a6c9ba71a215f86b280f6f5fa446447c0b1679f42f5bcdace00b3101e92471e424f2f430a0feac6dc063a6cbde41e6348f572884b6fb5f1a7a5c64cf0b9817efa8e3866561240328f3b1cba20c60f76ccac0b2ad1656a14797a2c370216e362bd99f5c198db332ede6e0265a266b5fc45f954fdfe152269ec1ad8074c3ccdecc4d4126c0ddf206e1bcc87bf2c024435658393194c8a11a5d95c45fcada32f3f41a4ca0ce14efd258bc3dbe6754c50d762107284ff33897832c3f5dcee285f3fdcd526d93a87bf3481a84d436e79a2dbcf88c39c284095c78837b10cf2f006e8abf966ca244f59a7d535946f91ce1f4aecfc310afd297868049d60c54542a0201e6545dcfef43fa2670a0ed1d4bc60ac3bfaa3142d9ac89e26e3b28cd5e1d733a01f8cbc17fd7a9388e465513a9b719345549836de095ba3405cb5c4a79a7b042e2865f5efe1242f1af4b63fb99841eee297e57ae7196eed81a546c38e0de3e64bd4a74ca627ee534ca51e381ab1915fba8affd5042b16a67f66c4afea5e9448cb0939757b499f590d9e39476a140051467622542b7951b46faa2959cb02a823c3c16f058004270ccd3b3a91ea80a1b0d18ef4755f542cecc7982df53144932a38e54d39aa7bdcd2f29d9f959d1fd56d920d698272980efa5b85012b7c1eb3a5ec8372bd23e40e4e1c40fdaf88d75ccbeb7b7d01707b487756169e32b878f69069034f0dc5807fe947a7615d5152aa59d97ed484b7b7da6bd0578a7e435e915ad2fb2026be879bc0104ee135a5480b6bdc6f9c12a2d7b200f141de5d0b44244d261952e83845aadf02a59e2fa0b437784c6b6a36a7969efbcc09815c2eee4ed92092ead36efceb4ec193b706b0178c765767777ac7ebfdf204b6d37f424c1a78e99c9eaad037fe18f03d3432d221241686e11c2735a98f20ebb593f2ce4a18a9f30f1e8f0f77db96298e9f71a3242ab4e74d55317d5397be004847d0f993a7b425da39d1da0b91b292e3fc2dff3b9311a30780a2a679398fb71668d451b1b1dcbe5959ca69ba74c2a2d644cb59f3caa73779a9da2f48cb2b443559f992dd89b853986bb097d53c477a8d3dc6900cb85e3e24d05ecd531141212fc8897ff7b5cb70cab7ffd1df25443e05361d7078ba814ca9dce7749fd14baf3ef7a48e9c281ed258609db2d8a76c9bf65ea7c4ac938a65eed302a5abf7afe017b502249e6eece0fc6b61aa0c1119248a03832c6bf6020f8f38667495e8b1465554e9e66cdbaff8f4675b661cbe26c4a00574af1cb1a4b3d22baa3a96e7ec7dd535f313492ad4bee972b3ee8244e1456047950992e0c600484bf92f4eea22e0f85decff4a109110dda8397923e5eb4842d24fc090cc88738b6fb43e9a05d19049aa81429360238e6d15ee65680d54910ace4907640cfb3dba1771b6023d0679dff9ae93bd6475158bd18968de8162406933267ff3c176d6b962168434dd8587b65f9717576e825e7d69fc101e692fe344e17925bfd5cb40d6d0d89989f414cb75e2f43eb478221ac740f630126d472c7dc147ab07cde69b8764549cffffb28b916c852bfca0ad13d42f7dc2c10bc5f3ecffd51909277366571b1a8489493d7974c9457aeda7a572ecdefb909ea7810bbaf83f9d5e80c9a8a05ceae4cfca82ca4068b704aff2af07d83c449b907d4e7d2878b25f867409d9ab26124e7633369188a68016024dc9efa787dda0a3f1efcffe87f70d3471dd578bcff9aa143aa970b1b95b26b3a53f84f8bf2a5f41e234d073e9949dff35210958479e5b8dc216a0b8ef8968cc6e57004d2b4641683cb0eb0fba50568b4cfb28c43bc517e4ec46db75c3266696f90229e80710f7402f5efd092ecd88ef75ffdd9cedfbc743e2eba3df71aa0651689249dafab86ba88bb2c6f10248cd8173170258d3a7c57e8cf84e4cdaf3605ce63db65adce2fc6207b540b8c6a96d597119f29c6efa768bfb12d3aaec3f77bd4aa183d2cb263b2b8ac96f4980e11d002172d4da3cd4159651288677d5518178255f1fb5e0bbbc9a7691199b1dfd9997e93a3246257eb1c0c36d6d9880a40070ae4b1655aa5fb3fbf4700c1552bcf38a185dc1699561464f2d5dd3ddaaf7adc39e2002f6d1708d26672208d3c8d7315fb19598488fc9b29abd8fd5060cf9ae5e439b198328fa459d5e3597271ee227ab0411d9f1ec8fd289f2ea17c45f0be919039df3f6e0d9629654","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5a33282e82b9de7920384b2f8f956288"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
