<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cf55ac30d35ee37e974a90e39032c5f94044ed6a7620f274706cfc79cb6de8cab6a002432ef53c48bc6f30f0a1b5471023aa22c3e8676b72b1b76b20b1fa6a200d81234d2df1d75514eb90bcf3b2caa17677ceedfccd2ee9fa19c0db33e613b9377eda0c245f4d6be4433c0b55140bcc84dce60c49154e171b7d09cc55cbbd65a9c2804d117a7151a862db4e4b275856f5cd2db5e9818f8009f11c8b3a5537bfa1ef0b25982be16adb28c2cbede4d80f96f3a4f6ee23445d6b0a8f505ab1cacbfabc628d28bc09bb9eff3db2f265e4a96b309eff01c78ae5c1727e5760bb606c3cdc7e80c0e56702ae3d0d2e75bd91e04df6db367a3ba1861c7229cd51909eab52fff05dcac5523a59b6edb4ee0ece36db9aae31aa5b2a729c0bf735569a26678df116445c667f9591aef4bc804d7946da80adf275690aacf773820aa36399075f91eb99421215eef01e88c2ff152eaad403fe234a752fc3d6c2361bd483856a04ac02e27d44db65d82fa049a95fab8df41d5ef6d2310ec330c83905a156bd2532e6e19a33c244e892f06edd42e6c68868baa2c7cc8af18e92fd026d4b109ba96d5a2c0d93addf29c28ced06b3b77c2f6f0ccb6494482747c609c45ba1f69d35bcbd519fb7dd108b059c905371f5dee99622c4107fc4f8342f57d6d9ce8df1b2accbfa52bf003e266b4c79f03a98a2b16c6e07153689bcc31157f1977734e1a8dd3cd54bd70d6fc15c2868e3d91a79d82e3b197b3165b664bfbdf3b2a40b6b7becd7205073b890f929900e013bba7a2b4deae70d4ba25f767cac939e075b7c43d2d23341a20b84ca39ebbf3fdeecc9346fffc74a9aa7de5dd878be0e9367d79683dcd044abbb56c0bc5e256ef8fe2d5b8669b36dc07a1662a411975e0e54efd8551379603e13d32d9ebe402c6bd65a9e40a35fa3c0f81a80376fd5f6dcff241012c8698173277b6035d7aa9e92338144ea558dde685f5227ea37be8b5438d1b773bdfbb1a25c0190460c82ffc294a276e25a0760d0ace4eade5ae8eb55275b1093aa64f238f884977ed07f49c284e60c8d26bee41a81b313e3a68b4abb3a03e3269ba043f117a8d01775c3396dfd2dba8d818eb52ce57e5eabec43ce16b0aab00ddbb317070fb18987844d24731ead8ea12858cd7392860c15aff5164f096e5e5c4aa0d024a8af5b7abdf71970f9712fb83c28e5d6641766f0c16bc95a911fa197c36c5ca62ba3ae6aa6af2bef061adf2a198762fa9b4670481dc4c236c28a858471c31a13dbedea93a3cdca095be43ee2a027e31cb70fb5ba8506f1c8b7407e5ba83125a7f48e848ccc82f5b6b1d51da3ad75569c5d6dfae5562174b6f8579fc2ceff25a0be34c60e70e793f9974828945ee844ade902502fe3b583a2fc85390b0e21729693e22a5badc388b780066870f52c844f96b61a9a6c572e06fe848751942a537200ca83ecb7bce142e0156e5d33d8dc85e53437065e8b64db70b9ffda273e49437b0573cd82f19e1c9861607013a58b3f20d1f8ad5d22a5d68ab61e26b82732e74fcf6716565dd42fbddd60b52feefa10d7b7c4b7cae7d0608d8b6984e1f3050918caffc236d71f3fa8f23465d6a7bd5ab405b48650a8d7d35931a831e12182ed055e2826b3bec39184cd5bd9bfe679450ce50ba10c8ea6186275ab1f21a4b1709cfad0687a9de8552fe64b7dea78da0ebff4ba4dbd84a855c5acd4ff7526ddcdd16ce7696f6e2f80917368c5ba0729248b04ef214971dbd422b937d1be8ced546c7cc55bb5d4fc3d4607618cd36f0d95461f97d828703f43f549992c7ff4a175958e1ae655b999d77dce076f2ef1165473c577d091bacb044fb6a06d66dab02d3b3b1294aecedbb1fb086f66446827643c51fe2044799fa870aa579b606d0080d7fd97d491d920679b427ec5f3ad969d2334a343a6b1045eb86dfb0128996638be685feb8fb135a145cc585f304446638514b32151b935a832d476f50764c8667f4b6ce29d4969a75a229de0a298781a6cc490966a20b1a3c363fcb7e4e0ff5b97f4bdbaf7e88f43369d136b35813950ce6923684ce4d6882f18a712b94baed970d5c511a9a27d6ffeeac19f5fb244774b5a3ce1d3870f4aaefbbd3eb203d3fe05175b685f4b0e374a14ff65607486c966a355988b479125230534c948d6064ac9ca412d0eada6ea0f37ac84e8f96c8fc62c30690d8f51ab00c0b6d2c1083211bed92efeb04523bba08b992c78d71655f22cb0084ef70a4ef597a984886ed58c1d51894179ef545446b31ce610fe92c2b423c9d6d2b40146642797ffbbebf42e1cf76b0c74caf405ef1a1e64a2296f46da00d997d9c4e95af7e6f76d91196affa563c4af1abde43d039e300e24743a1af5900a8c6f9819fb14f4692a1df7020f84b5a6b0bde06cdf42df1b69bcc99af02390c8e4b043dd98563e83c85a71fe7a7655a2b9a568436b0f1e1b3c72ef8e77ae70862d3504d8e150efd96c43bf1bef0adc6ffc91aac317df3ab5e59cd75d39035200d89b5afd6840f8299e5096d06b6740065f233d1d55dc5d15ca44a97c4755bb5520c771bfa96fb058896d3308ed2dc5f50518a9ec7950101ad8cde29bdae51aba0c1e1499a082a3a128a548c3ca170b5a634633da6d7f05ae7c1ad846e0a31e9d4c5c7e0e82713a15cf3afec6277e02d5ff9e08281ad1f3615036d25383e0b821a144552aa40e7ea456a3f3e9a63a1e44a16600730aef838eb52d8abc5ecf7d611ed65df948ae8b0772444d56627a67ef181dd9b12e6789b2693164956f3abe769be891eb3f64eee1dde187e3c7109b6a7c88a325367ea5d594200e947081a0a56b5192c95c4edf5f0b543b082ca7b148aef042b9e26398cf2d63b680dbff516a18a272dc276a5d48807008ceb3bf76ace32eaf625b3d912ca0bab171f475852e92ac61282aae89b1461286a34222663b00ca1e998530a5d800fe2363d4b4b850a6475533d379b7bc063a92bd39636598ec6a7af36ca4f2495ce2223f24b2c8b8947309c387f8e4e9c81a2b5b1457c338f001a40ebc9b07fafa7de98970c59a3a6b3df4dad88da5d29ceeccae5e791b74d65f465f068a0183d9ecdaa792530a40d4e64fc70b81ba63f976ac322a6e0e6600619fdb3d83d2d3d2e932cd03db34129ca12ba54b6fc4d521a5b3f4bb1caddc4c6afcb5e30f50e431ff335bfa730c4c1e3f8491b0de487e190aa3a9d90e6fe85d92ae20edb5999d344928fdbc4dfca84f6c1efead18f0da72617cada57b712551a601af211aa1eb1c09a1281e670407ad93e8c8d5ae6eab88bf1e4802e93819e27963cf2e75bb3521ba1056539e0a02afe34a5aa70ac32ee0125a8b66a6162754da95ccff2a3fcb2e1d773a73291dd8f097b0e309f22bcc3719cb3b25b70cecb8561d6740919b6d2be810a3cd23141affcf49f2d1feb596d429b9cd688220d7f40c7e2705bd198b665a6ff728719f555c70785b1d78649d35e4e9d411510dcc2d4163c39a3bcb6090680b5f577f8e5a17b7c27d90fae1e3e370600134bfbce8e0fa78d446b05d51c17799606b4826c107dec484c4f0a578f3118e9d2bc16be102b3d638cff98f15d28f066431dd640861fd25e84778c30a582431c6fda1e421865db3b7a09d24e45a9041d4b08168d62d5fabb01dd1ff0678f81c588d05b6a4771127165935910be77a0e48eebd2dd6734ab46c4a7572905a55fe4982274f647d480fb2b5f2808c74fba6c1d4131317ce7b1df9360d34dad80af9737c2560ab91a56d02372e5526ed02d325e971b0bc334f0436def128033d2e6b8970214d57665edca294d2ed737f62e2d1bba71c271ab8d3a36e7a047c28366cad1f7058db0544dec2c7db0b7838ed051c746c6bf2068b5a6401baf698d7437143b8369853519573543a873bf1f58c6b7baa983c8af1f8796c6e4a89afcc1aee7a93d575c756733149cd86f729b208fa74ea0477b30e2d2f966d104c4f54e2bd7c22849f6789f63f7908f6f4f7a5ead0459caf3ab8d8abf253920bb812819dd26db83ca8949f242436ba4730f50b277a1c3637e18cc62684986c6413874fbb6f6231d269b157859592ca04ab3f7b3e1c22f189db575c6017f0bdceab01b2d196ed25271e00642547425256c91ecfdefbb67e0a0b976ff6624c554af9cc96be59565942ad596d3b91f36e83627a56b1ba31c4b31bebcc4092bc222f8399f908a6502e5111ffa5474103b210c7635df3d4eb5035197dd162fdd6e3bacaf3784f99ea5ac21aa4101aef8bdc457d66efcecb35fa276430ef19c4dd361f43adf625832e2a556b30c39e1c1d8bb92f55b5ffbc458fc27fbb35fca18b5cc8e3d43b8509a9b8b4b23db9f03ab284824b4407d49d18953016a91816281a5b6ef44e22188fec99b129c24283691ca320c6528286f75b2010b3578a3f832a9789654942e1da67b484b2c17f6ee265c1c22b405be8e010065704131a14daff9647ce37d73f5a6be8f8352e47c01b9c1ad8ae476708e213c4272c17794c5e6f6f40044961b26f4e96d5a535fda4200e54d7119b21de7ad1719e8bbc0fe87f97274ddf7bd9cfc8f729edd934886bd4fe05b139f180edbb3c0fea9c377b9a270b7f284a2860009245923343689917b9a61930071690b3d58a8c7808b1509bd4f44760e4af3a8f253300ce6d5452166c2506cf147c36668a611a82f087ed7f9baaba8c2ff3452584196e5546b88053bd1ab0b9c966234075698b0af73f2124e958b431930aaaf12a218ecfbfc5b3f66049427a1e491fc80b96a850e0190f08084d1060595567514ba3845d80fad8a387355e2f502b021881995ac8c638b3893197aa24bb2fc5638675d57ae33a25f42b23b14eb181123d377be208da0bae4404b34a0c104942ed8aa55267515604461c4f44c0a82ca6522f8a132f66690a5697f85ec015ede4149ac2ae5cebad7630d970fdbaab6741ca80a1ef31831290beb9fa5af09ed4a4b26be7e23eceaedf7421e02d18c9cdda43a619dd20231546db9790ffac0a8598f96cca46059873588f04f5969a5952f639814c535dfba94df4dee406da1932f8152f95445abc0f27270c86536fae59e8879f30e509dd787d07012e54a22afeff055221a036c501d858935b042efe61524e53cd97d750232a069111a5d9b279a0d6ca38be99b38e156612d02d88dc4fc5d90c6628589162c72c5b882d6fe88e3fa32b636e27044b12d5f07a105818eec70ea0262e195987ca2d7e81fc19bb03544c1e0d6b8aba7b8f52ce430092997393726ae6a548010437a9b03ff4d3be892c1f16640795b375072186ae183d191966b7a3bd2bc29e82f8515b9bc2840f8b23220cf82069271221f51a3a426207993d9649450c0af3d2ccec96b1c1b7801abad1ef69c3b6edd35a8f9137b10944bdc7a7ade888aa0b2a175660c39ef5615d0f3fb1eef2a77c1dff1ca9df96b94bcca1c11cb90732089f70e6116a1d439b166d62fac716046887995c31d77dc9f4834cf87adfcd9f665fb7fd25c251479c22fb781064c00004bd4135fe2903437e40197f827f826fed04564f140961c3b34c7d95819b3bff6f211c277f9bf613e0e28789f856dc3244d5fd2991faf6543f828981db2c9c10d896bee1a8acf86ff24ca748e06cce2960c21cb061ba6c6f3351a32e09591803b8e8a6b2f97d68518f9b8a96d4760bd30bc5ff157f96c2927fdcb24d3c23104c8db73c6851e11ea7d6b433f88fd560a863dcbc57262c09f5612cc920c30dccb9359b4ccb5d4f49f33fa1379be9e0428a1d4cbdf87d2c9c3f009d5b38802af343859d00938d5f7d205cd101810e748413ad22f7fd7f8efb03dc7ef1ee47fe74f69b0a4a855ef0d0fb15a1d920f12f6a25e47deefd858e05b0bf2916b8110395f6d14bd6c3969ef303498a86a0c1770c572c42f520b3367251ea9963bde5c415edc3ef4f5f27470aa4ffc3f4d494d22977852639dca9afe2e10c21a6e3f440da9613b16a9775a4c73cf85837d7a89fe2ec8352913bf55cdc5183d8e435608aa73a36ccaed890b1edf0334ad4579d54ef11a05b53edb280685a91ba16418ba5a7792817487f79202e80751678639ba8cd22d46d08132db01ec4ebf4b0b8101c65b8ade038742e4c96b2563a93546f68230aa9e4eba10463fdfedc793a9aec3d58619fa2c60c3b418d50a251c1924696cadb81ce4fd3f226bec3b34b1ad66aab072a608a0a4e46437863894274307ed5800ef93a192f8f1c2c091e9444bd77fcd6939cf4e201a6ddf6d6479e75ab952e93f04880882656c87c895d28c25a118b65ab1ed1aa6371972420bfab4081b6ed5e24fe5e198d2f8666339cf3d351facd31a12d9f948f59648d8dc429049ad0509dc7eb78e97148e4e844ec31f15514f540fbf787fdc0d2e2d58cd1a6fbda46e3a7f8e3bb749ab62d6aa4abc8336df399a7e17252725551b976cea59277fe2c7d49fd94ef9a6947c00abaf5054d3c79b45d57cab301c7bcf1bdae6bc5bc900ee77855ab007cfe40e9a8e7b5a5e8e590caabde1bef1b19967cfaa720d09382a1eaab4b80d233e3c9a9da515f88c09af6bf7bbf3da88df1b70ff2250a35e2d1a34a52f903492d2f3e7a904910e00ac40a91b5cba9765e09222dc90d4a873960c4f9bf2f24104dc6752057db5d5938af0745741fc6aa80aabbb5666b30610443de0919750f5786207c566e113f26e38d934b0d50feaf5946ced09f11c309c334942a42beef09daad8e725dde3171a39ef60b704235422ee33d7b8413dc098c603a1926d7db26e316b108546f8cff2c6493c35d63b2a0827380e4499277615f2ddb14bafe5f1fc3af9e40567a07742a07641fe840f4e9c2e29a8399f14942f14fb57ad3914bba7922aa210abe9b17529ad29107d50815360dd1b7e60078721ae97918b5facb6292e36262950ee3777c5e0dad8f9c2dfba169d67ba3702c209aa60c0c9843707f57f55f825325e8fd37f42e7e6740a6159f5b2f479f069df52d2cdedd49749f0d2d58554ac07e67f04abbacba6fc2650aeb64e08113e09cfb39925281e5a9c00711ff2b0e6cb39ef0fbe10a793db4af14cb18ccee78d688b31fce4b8e53d07abc9eed3bf7fb353d9950952f9d6bfc479ff5081c7183b8f13fe53491aa42c1207f1d34a6990025ca11b6c38f1e8a258fa35df5d2bb3df1a971452772fa27af64635e12ef7488ac0cb627ea6d9163d013c0268930eb1c433ac0de7694b210b2ab2c9b14d409984f0df0f0719dbc8a706dfc61ba6bf65ea3f552a8e69fd9ba4fb769da154685fada6bbebd61d51ebf1a444f0c27fb105ea6f6391d4f96d12d4a2d4c22f3907e8f832453684a9d2c007ddee32f5ed880e7036cb6f2b15daa5a7fa2beb9d110ca4ef22d2e98d08e772bede59d3a695ed174bb1aa4859542668cac3dcd601388cb5f6ffb574e3194f825aab8c8d6e67ef9f15bb0a4a8db5f47e2311f8f9b374bc3beae0b4ab7a556ed6e220c38bd7d2bc27a74b76d9659b434e1e08a762118fbd0a49f70f8d108bea93202350dfca759c5b6ef83af20cf6e9465cd8fad23a93a5aaa8d77c9da787592e762c84498c770d8c3ee822a8b5ac1f77cbb3e8610a089c8e542cdd83c4c3c9d79405c7a8a10bfc1dada9204805848bc3faf06e59fb34b69d0b29cc4602fdd80e89d514e6605f7a0289fa1e1a2254552f732c068ca4431f7b0dcc4ab75181f7202a1f43ae5b2941f5335ef764a1d217d85a55a7b10b5333a4c054ba9a385c51de711db31022f3f972b639c1fd006e0c4ca4331b70b38a4be9eb4abf3b0d9ab2e995a751a2a383369f1b434c363b2827d3461c3da86be536e0f7c4dce5c3290a496f86b3be67cf7d905b77ce0edefb59d857f5483761abf8aa20e93671d0e61f6f060168b531a3f8fbb3b81066fe97d3e2aaaf683b27a90cff28e40bd50becff3ae5ed27721b5989a08aaa5155ed8e46a51c55829878aeac5fccb262f6ada0212dcc79c7d27231d79fb75ab9b9197ae5ab208eec75f4538953d2c7ad68c2ecbe1df1ae881c36df62f1576bc47b8018d9f7c11975ee41372054b5323ca35ebe50978237ca3c69a8a44aeb271dbd7202af9a9e3e6425e4974d3e62aec91e23e58c12f892ec2a2e69f83732fb6b1033e5cde754f41e39c0d0fffa9f9723bddfeb4fe060073a617825969daa9cb9789586742e812d921403cd3e2f3e586a985c7191e6d5708da79072e61473078752b71d7796de6c87d1b330538d8340ce6c43c5c89cbdd47782b93a38c620e558296c1ee92fd543516cb73d2cd1aaa8c0d1748b6c55838e26f05e898743947aa4945f75aae6b63ce1f66f839638e6d6d1ec49147c5777070edab6c059b993cd6cb5e9bd60964068663d874fb582a03d83e712ca606cda48cfcc817e8f6d9029acffdf3df33cc0c5e946e8befae316a7fa8276d5e31ac054a86886e8ba4118b106d1bb97d3207555ba53759a816212757fb454f53710e6c8dbcc19ec934504a8aea4d6bf1a5407f4b8ebe071f3345da3ea57a165bdccd67674e8ec4a494343d3e7549ac8715c4c7d36b4afa6eafd6614d12049b58577aa5490aaa4e99d1ca2ace172d6f443a34cdefcf4625ce17e5b2e5a6349bc43cc7bdd95bd35805e677b6724d4349939291c4ffa5f8e5cfe8fbbb1009afdba84ded871c789f42e1828582b173ab2bea37409fb6f78dd1c4d558ae197ea9cccaad168480c8a1cc424e80d50832739189586c68a5a4633fe2449609642efb768d0ef414300c242b11610adcdde0e55542ca2e4bfaf6f1385592c22b360b9a6e138a8a7ad6c91ab7e8b2e68d25a2cf357b0d21800e248ea5116d6007a602f4a536475dc8af859d28bbf157746a54d5a423dd1af25dc851a9e0380373e8df9075fdb8f3e4fe572f29439792d274f6cabc2e75db8717b52ae4605ad2ba74b19bf8cc0d44873a475130248e90321013f27b0327205879ad90de1f964b1414e19a30234d6cab56971a529ae68f5ca317b94b996792cafe516d52ebdff474d4ad372f61fad328855357fc9ed2a986648934671e209b346aa72f1375a9640eba8a0b80c8ba07c5617f0d0886cca325a21253974d53864b2cd89134af22b88dda50c3798830d744577eefaa7c777ea8ef7082f30570bdf6a23ed7b77e488327fd4fba926ea894ac918e20f52e2fa3a7a3ea3cfefded6f7afddb2907d01e4c2b98d5f29b7dade38f4452a5b6089e544f49daf644940da9fc9a9399f50bd8401db6a7fb88c19a3c07b4aa839a4de963a33eafcaccb87f76ced68f59ddc5084381d13ed27b803ce6036ce2a206cbe65b2cd3ea52b58ee573ef65282a1c91abef70654d6d903bd209415f0faee5607b9fe7281cf623a4cff1f1eefd4b8c246784192f606b1ea71f654e0f491c65c0d6e48a774ce93bcd14feeca1b84de431ba64fb370f303dd5cea4a930a9845e6707f7670407c85ed0801c49e2583971d383974aee7c389b07e1f620d8c0bd78c481129d2f13a57101274f90b6d6de87c1fbfafa3c3db0c64175a380708e79b173fdb1ef2508d871c6fcc2ee563c87dcbbb268523d52f82155da722d7844a4f1ec6c26195ad42854b9b683ad089988df5cf42d751a83ede5e7585bcc22fd87b010923fde1f3dcb54a790103cf3f8dc0f020e72c683e89b8c1433b72a5368ebf0bc73e54db184fa8c1096364bd7c02e76731268ff63f477b7e06f634ec16ba98fa45703bde066a13c63abba30091f30f0652fd2eb02a957bebe8a74261e590e7ef89f61f9dd4ca3ce2bb36c96bd6208f5cb781734ec13b580fab7c915a71b606ab2a5751fada1a76390ef041186568c0fe0a00894a575b8719b1f9e062ca87feca679d58c54bce6adf3b0e5eb3047b3e2bc859a479a4c9486e7d3cd9d9dc4982e6486eead68f9f7059a3aeb38a5ecbcce37af7a3f39f45445ff989ca8d3ef26438445657d5609f020c37b51c73e3c32071b1a2d2472b18dfc02949970dab878381dd636f6221a32c3d20b9c41836333abdc0837c53e80faf3c76a1f3fb817d25f938f830ddf1b84a7663164621dc29e8d48bfef792f6221d6e780badedef474e137ca6d2d393be0ca681e4322a2771227f4866ed4cf77d1171b457b860174a607d474d02a1f54dc7bd88e06fc5a6ef92fe42980e10e95da28df36a19f668418889f19ca6ba31ed40493996b42283a36c7d5022df8dbeb67f21d59e4466ae112cc9017bff67d2efe410fd44726bdddae252cc6b94faccdec544ba644962715f657c4356c7a68c59cc8f33233401b8892e679c123ebfc8a892cf20b20302430501d1cae733cc00d99d52c6c14142ec95571e330bf986ec197d8d8a0a2188775c9f01ae62c72eebc00197b2fcd21994a4d9fa70ca4b1d55504efd6718a9847b7a2156abf0204e9c2cae5335a3b6f25ea177cb8a0e40cf658baa55898ffe32456383ca85414ef71fb2b87d650b4478106daf760abc400d3fca4f98d0c808d7334a8f5d8c4a9ac9418485ac740d8e3d6010be15ee1ae5bafb9761ecef330519b9d0a736c5145d946156a754892f707b8469d41349d56db3ab130604aa810949449a024183479fba2d31e9b5d712143eefb7cc4cff6a161c9ed320b5bf645232f94ce4fd5508a9807bcc01ccc6e27b68594154f23b2c1d1fe3de09592e9e4421adbc9297a930ad99ea41547b1f1b791138b1cb2bf1c7b0eeb43ff5bb39ec79f0b9ce98dea755f7b3d63c0c60276fedb79e88c29c1e285ed60d9b91ee74b5e643f2d71af84ab8e5ffcf7e0d954697dfbd3cdfdc08ce4393f856f45a50f5638abaa0f3a2f81f39c32594d0f1d1cdc2abda387fe08ef78b9c9e8b8c360f5336fabedc77aa675fa05681fd2a82784ab85780356699286915622e3d4e99e0641858bb7e8947024e29607ea045f4ac21773e10a795a00d5aec3ad0289a1bee806775ec40ecdb0ad48154c3cdcfb17c080895c4cbeabe999b62360d9090ed879eda901a487dc6a3ba26094cab54e34200a86962c266c7047e267921a87ab0067c03f9589d47f341e196bb478ab834dbebc3a336872dd40d5ecf7a2b90b1f4a1c0410cad985adcf3cd6320d434f2d2daff0024af6d3de5625089c7ba0bb8993baac419035cd28595044f6230abf364d948a4da3a57e177bcfa6477358568ba3417c8b48617cd7317d2dda8475b3cfd1e7ad6b18d9f0ae1bbafc57f9fca3e7287a60d68bd15ed93d5210066ac62c913f29162ac38cb97457c9607654fc2725ec7b2009cd0afca64727d4e82503eb0b857259a6dc7146014746056cba1807607482da4f6fe09a2a5cb615c820d2094e788664a601ac1d0a1a91079dd3d4adea4f9810d3f7cbb8641478f2254587d6b349cac23ab78176c631985eb1a2cd74037d2cb7f4d9c075042f3bb1b0cdf802025470f2adf17279557347c6c351dde99f9157341b6f641ceea47e9adb449b02c7ec4da71c150818527ee008056bf27ba0ccc21cbda6d7679eebf0a60f42e176f953b26ed9954ffb7a87e0e15d4240a4402b806b16c97da8086c276954557155b79a0c5a5bf158d6ccc2332276a5f8531202250f30438f677696eba437b2ef5954b6fd9b1a51ba5d99494fd5d2e4d25909ee4950d99416e5b65d27ce4ef653a1190870aa44d853d941c116e99e2a3676e6c7a77191ea7f2a38783876878ca0e5d732c9d4ed3ad3d1cc989f7f7cd8401cd56ff479bdfb633160dff55c579f3a6a4cb4bd3697ade95451cb91ef30c78ae6aa8fc7b66a39a64ad6fe776ec70d441426621cd8e49215b3e4564e867c263ec3bb24d7f631cc838921cec1bcbe2223988ca2b43f9989247daed720f2496a1c10db4b4f11acccf92e61f65e1370ceb36ae6861e14a875eb28d81cf3b1ddeaa3cc21f585d77fb691736566143d7be04bf0934b6e95037bb719a6dfbe9412ceda557c7a9dec69b7a33f0ba26cdb532c0a4abc27f30b9eac311b533680db1d6b8fdcea153ebf5019280845ae63218131decb6ad3bb74f621e82d1f6630822717e93ac634bc8dec80c07d7dffb064b4dd9a6a28c360e16dbcd472250158b6c4a550b20bc8d2d39a9a89f798ddd1df877a95085f7c396fd396f3a6c0cc5cbbaa44c548e55711ed9ed1a02c5127fefaba6908e597f7024c517114822689751a865f3719acc05f06d2c021c8aca05ca30eb1c3b55f092655b379f963762cefe687adc0ac68fa8b165abf13e6b686dcd44d4da89d801c8f4513650a8b28b0ba5ceec28dacace1fd16e71ccc58d0362bd99457dacf6bdb542e7ee793a459a0490b5ba5782f425581ffa8c3e4fe82f3db8cb3e6196eea3c88c782d9bfce26e5910ca772e0294a18eb950e690846156ac1f4e2f7e2042441812641922d2aac9a7a63a50ebf938a6dffc0e8987e350fae4a25a7eb18c3b14b50d535f60bf9ca81bcf688b4d07ae95fd31f111e6c11512818e3459ef3451475bb579fdcdb9975a1330f0b695e3c9aa20ddc1e605a2450c9fe5d02ce605ca7c323f340fddef03d09f71b0ecf7b07eeead63d4ef2c4a5c20a404cd0279cb8d93070a0898c989d08fc3f71163b273433d5f67cd58549863b7b7adf9f08c5fa6917e9ba6d85a7d0dfc5ffcdedc85eb605de5744c4e2118f21f9265ecc36db2857e937d60a0d19c77b69b22eeb616ae47f1f64eb47cd854d90442dd603a9cf7e482a830145e8ab00d4d0a454ed58b269dbe8da745afc64d01ccabe413a97f3c1eda0ce863f2caac5ef3adb72dcde87f19bc8699e349788605030289a92ea3b5443d4822230d5a19afcc29a11e88baba90dcf66c9cddbae1658ad3c75091c2fdb546c7623d2ad06ce2b014a104bfe000b27b3b41531be60ba145d3d41de86618c799434b87c15c6ab8d0dbaf863473fc7b8e8f77422c3b0339a0d02cd10291950c0edc7b4f0b34149603ef0ba5fe0d3cfa69f861beb3ab85d14338e15b5ea6059571183db8f300c63f3286b33a22d3c3af1faf3fbbca4742b7348813957657e240f590a5db108637442f84d46d76727a6fee86942aad89d5ba5768e9d83fd88b8d57e163320aa9c925fdf4f917341cec0d076ebbb073721a60465ef47935276b584c58d7ca808545bda8bbfe60b5a3f1397a129593ff1f804bf97d308edc10485ef7de16a7598658183b932410fa698ffd5d4b90b519296ada3ee9f0fc64ddba5057b0903d32498579c519f5b2ee0a03a011f60524b012a7e9c105d262ab0a606255de05919dca4446dfd8cf5345d34cd681b855ed027281bf7e0edc00e84158db02fc355d274f43da3e9e0e1db4eabbca0b79f825e9b55c8fb9f76c750d8a573b00ca6b9040d1b9fd3cf9ab3891180cd3b4bc36aedce40fea120f471093b3f94057782ddbfeb5e10c7dd3b1d570b2d20bda4d42c2f922cbf448967bd86addc92816fd826ccfcebefdf8c7a764aaab30762584fb3da326e646b1ba00de4859e9120eff90a88c20fb38314b911f5166106414f21c419647b4f72096b6d7a4c22c82a410556de2b1d7beae0d14f57f547482f08dd31af479063ed6da7385d55679ae771859da060ed100ca6e20b38450a0c592611ddc310917f9fee81aef0ba0e3c2cbb342588c4b0295b943edbf81b95f72ffe596d89fd2fc13869f8830f7c2b661d43600f9e9cb67a57287e97f4f30201d4a0a7e26213b651681fe87254933a744b4a9d5678b9cf406c466419c5bb23c45e95b6354db1b59ba88f62458eff58f5426ab291e2367cc53baf3ecbbb2fa1716d34644f8b0de72537af952b017214b530c63a0639cf32de1e4912c373f7603d153d58cc5e4521be32d2f5694849aa338f352a15af95c132db662eaa2093e270e6101b46ea85db60b4053589e55c1cf4e4f8411efd823c181b218cc45487b71bccc2388cca7360a28a6247a2885002bbca4914ff578652312a199a25a730a93c6230fafa12027f67c0c113f3df770b12451f3c611ad0928ded5de29a40c462c2b156b08c90af1d4d08d37885c5e2043150bd49948af325250ab6eff15f1d83ee4fb8125df8ca15eb25ac4567ec6a7438ccd43dab39df285aca9592f939e0a325337f013a0a8c52b0d7890f211ad5305898035344ef7b1b574f376f4ad5debc780ad7c073cd3220235ed1713de9be6cd342bbb32a65d416ca74e2ec40dd8dd0ea3e169b33d2e1567d425886e3df56a81896b0765439b38e2d76a4f888434dca466ab97d9ba4f2154b73bb6ff10d5ac8aa4a087965bb27e82b33c33ed6846c06f46b40a39eef5938818107e603b1f86305ddb96ca3c10a1109f825893fe88fa2ac9a7c50809a85d6e6bdbb0195e95b6ffdb679d8d3d8c33f02dcb1b409f28ed3a02c18f2b8f9e06e56076697c65801789f6d1679f0add4bda66a87a6d366a2afb0913eb0350cbd90ea467d6e7a3dd3439465d55b854e0e5f3406b202cc092fc2050d70a97c5cdc01a872e155eb6cb7a9fa664c2d78accab1fe9f97e9857db1a6e31cb9496e8717da1f5275c5b8d390d5d5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ff7f8a7178e5bc749c2cf7b34968643e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
